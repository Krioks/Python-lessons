# Условный оператор

## Синтаксис оператора `if`

Все ранее рассматриваемые программы имели линейную структуру: все инструкции выполнялись последовательно одна за одной,
каждая записанная инструкция обязательно выполняется.

Допустим мы хотим по данному числу `x` определить его абсолютную величину (модуль). Программа должна напечатать значение
переменной `x`, если `x > 0` или же величину `-x` в противном случае. Линейная структура программы нарушается: в
зависимости от справедливости условия `x > 0` должна быть выведена одна или другая величина.

> **Важно!**
>
> Новые строки относящиеся к оператору if должны иметь отступ. Т.е. 4 пробела, или один tab.

Ниже используется условная инструкция `if` (**если**). После слова `if` указывается проверяемое условие `(x > 0)`,
завершающееся двоеточием. После этого идет блок (последовательность) инструкций, который будет выполнен, если условие
истинно, в нашем примере это вывод на экран величины `x`. Затем идет слово `else` (
иначе), также завершающееся двоеточием, и блок инструкций, который будет выполнен, если проверяемое условие неверно, в
данном случае будет выведено значение `-x`.

```python
x = int(input())
if x > 0:
    print(x)
else:
    print(-x)
```

В условном операторе может отсутствовать слово `else` и последующий блок. Такой блок кода называется неполным
ветвлением. Например, если дано число `x` и мы хотим заменить его на абсолютную величину `x`, то это можно сделать
способом, показанными ниже:

```python
x = int(input())
if x < 0:
    x = -x
print(x)
```

> **Примечание.**
>
> Одну и ту же переменную мы можем перезаписывать множество раз. Однако это не всегда целесообразно.

### Вложенные условные операторы

Внутри условного оператора можно использовать любые операторы языка Python, в том числе и условный оператор. Получаем
вложенное ветвление – после одной развилки в ходе исполнения программы появляется другая развилка. При этом вложенные
блоки имеют больший размер отступа (**например, 8 пробелов, или 2 tab-а**). Программа ниже, по данным ненулевым
числам `x` и `y` определяет, в какой из четвертей координатной плоскости находится точка `(x,y)`:

```python
x = int(input())
y = int(input())
if x > 0:
    if y > 0:               # x > 0, y > 0
        print("Первая четверть")
    else:                   # x > 0, y < 0
        print("Четвертая четверть")
else:
    if y > 0:               # x < 0, y > 0
        print("Вторая четверть")
    else:                   # x < 0, y < 0
        print("Третья четверть")
```

### Операторы сравнения

Как правило, в качестве проверяемого условия используется результат вычисления одного из следующих операторов сравнения:

`<` Меньше — условие верно, если первый операнд меньше второго.   
`>` Больше — условие верно, если первый операнд больше второго.  
`<=` Меньше или равно.  
`>=` Больше или равно.  
`==` Равенство. Условие верно, если два операнда равны.  

> **Важно!**
> 
> Не путайте знак равенства с оператором присваивания `=`

`!=` Неравенство. Условие верно, если два операнда неравны.

### Тип данных bool

Операторы сравнения возвращают значения специального логического типа `bool`. Значения логического типа могут
принимать одно из двух значений: `True` (истина) или `False` (ложь). Если преобразовать
логическое `True` к типу `int`, то получится 1, а преобразование `False` даст 0. При обратном
преобразовании число 0 преобразуется в `False`, а любое ненулевое число в `True`. При преобразовании `str`
в `bool` пустая строка преобразовывается в `False`, а любая непустая строка в `True`.

## Логические операторы

Иногда нужно проверить одновременно не одно, а несколько условий. Например, проверить, является ли данное число четным
можно при помощи условия `(n % 2 == 0)` (остаток от деления `n` на `2` равен `0`), а если необходимо проверить, что два
данных целых числа `n` и `m` являются четными, необходимо проверить справедливость обоих условий: `n % 2 == 0`
и `m % 2 == 0`, для чего их необходимо объединить при помощи оператора `and` (логическое
И): `n % 2 == 0 and m % 2 == 0`.

В Python существуют стандартные логические операторы: логическое И, логическое ИЛИ, логическое отрицание.

Логическое И является бинарным оператором (то есть оператором с двумя операндами: левым и правым) и имеет вид `**and**`.
Оператор `and` возвращает `True` тогда и только тогда, когда оба его операнда имеют значение `True`.

Логическое ИЛИ является бинарным оператором и возвращает `True` тогда и только тогда, когда хотя бы один операнд
равен `True`. Оператор “логическое ИЛИ” имеет вид `or`.

Логическое НЕ (отрицание) является унарным (то есть с одним операндом) оператором и имеет вид `not`, за которым
следует единственный операнд. Логическое НЕ возвращает `True`, если операнд равен `False` и наоборот.

```python
a = int(input('a = '))
b = int(input('b = '))
if a < 1000 or b > 1000:
    print('a less than 1000, or b more than 1000 ')
else:
    print('a more than 1000, or b less than 1000 ')
# В большинстве случаев этот код сработает корректно. 
# Однако есть два случая, когда код выдаст ошибочные данные. 
# Предположите, что это за случаи 
```

### Каскадный условный оператор

Пример программы, определяющий четверть координатной плоскости, можно переписать используя “каскадную“
последовательность операцией `if... elif... else.` Рассмотрим его в примере ниже:

```python
x = int(input())
y = int(input())
if x > 0 and y > 0:
    print("Первая четверть")
elif x > 0 and y < 0:
    print("Четвертая четверть")
elif y > 0:
    print("Вторая четверть")
else:
    print("Третья четверть")
```