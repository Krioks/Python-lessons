# Строки

Строка считывается со стандартного ввода функцией `input()`. Для двух строк определена операция сложения (конкатенации),
также определена операция умножения строки на число:

```python
a = '123'
b = 'abc'
print(a + b)
print(a * 3)
```

Вывод:

```
123abc
123123123
```

Строка состоит из последовательности символов. Узнать количество символов (длину строки) можно при помощи функции `len`:

```python
a = '123'
print(len(a))
```

Вывод:

```
3
```

Любой другой объект в Python можно перевести к строке, которая ему соответствует. Для этого нужно вызвать
функцию `str()`, передав ей в качестве параметра объект, переводимый в строку.

```python
a = 1
b = 2
print(a + b)
c = str(a)
d = str(b)
print(c + d)
```

Вывод:

```
3
12
```

## Срезы (slices)

Срез (slice) — извлечение из данной строки одного символа или некоторого фрагмента подстроки или подпоследовательности.

Существует три формы срезов. Самая простая форма среза: взятие одного символа строки, а именно, `s[i]` — это срез,
состоящий из одного символа, который имеет номер `i`. При этом считается, что нумерация начинается с числа 0. То есть
если `s = 'Hello'`, то `s[0] == 'H'`, `s[1] == 'e'`, `s[2] == 'l'`, `s[3] == 'l'`, `s[4] == 'o'`.

> _В Python нет отдельного типа для символов строки. Каждый объект, который получается в результате среза `s[i]` — это тоже строка типа str._

Номера символов в строке (а также в других структурах данных: списках, кортежах) называются _индексом_.

Если указать отрицательное значение индекса, то номер будет отсчитываться с конца, начиная с номера `-1`. То
есть `s[-1] == 'o'`, `s[-2] == 'l'`, `s[-3] == 'l'`, `s[-4] == 'e'`, `s[-5] == 'H'`.

```python
s = 'abcdefg'
print(s[0])
print(s[-1])
```

Вывод:

```
a
g
```

Если же номер символа в срезе строки `s` больше либо равен `len(s)`, или меньше, чем `-len(s)`, то при обращении к этому
символу строки произойдет ошибка:

```python
s = 'abcdefg'
print(s[10])
```

Вывод:

```
IndexError: string index out of range
```

Срез с двумя параметрами: `s[a:b]`  возвращает подстроку из `b - a` символов, начиная с символа c индексом `a`, то есть
до символа с индексом b, не включая его. Например, `s[1:4] == 'ell'`, то же самое получится если написать `s[-4:-1]`.
Можно использовать как положительные, так и отрицательные индексы в одном срезе, например, `s[1:-1]` — это строка без
первого и последнего символа (срез начинается с символа с индексом 1 и заканчиватеся индексом -1, не включая его):

```python
s = 'abcdefg'
print(s[1:3])
print(s[1:-1])
```

Вывод:

```
bcdef
```

При использовании такой формы среза, ошибки `IndexError`  никогда не возникнет. Например, срез `s[1:5]`  вернет
строку `'ello'`, таким же будет результат, если сделать второй индекс очень большим, например, `s[1:100]` (если в строке
не более 100 символов):

```python
s = 'abcdefg'
print(s[1:100])
```

Вывод:

```
bcdefg
```

Если опустить второй параметр (но поставить двоеточие), то срез берется до конца строки. Например, чтобы удалить из
строки первый символ (его индекс равен 0), можно взять срез `s[1:]`:

```python
s = 'abcdefg'
print(s[1:])
```

Вывод:

```
bcdefg
```

Аналогично если опустить первый параметр, то можно взять срез от начала строки. То есть удалить из строки последний
символ можно при помощи среза `s[:-1]`:

```python
s = 'abcdefg'
print(s[:1])
```

Вывод:

```
abcdef
```

Срез `s[:]` совпадает с самой строкой `s`:

```python
s = 'abcdefg'
print(s[:])
```

Вывод:

```
abcdefg
```

> _Любые операции среза со строкой создают новые строки и никогда не меняют исходную строку. В Python строки вообще являются неизменяемыми, их невозможно изменить. Можно лишь в старую переменную присвоить новую строку._

> _На самом деле в питоне нет и переменных. Есть лишь имена, которые связаны с какими-нибудь объектами. Можно сначала связать имя с одним объектом, а потом — с другим. Можно несколько имён связать с одним и тем же объектом._

Если задать срез с тремя параметрами `s[a:b:d]`, то есть будут взяты символы с индексами `a`, `a + d`, `a + 2 * d` и т.
д. При задании значения третьего параметра, равному 2, в срез попадет кажый второй символ, а если взять значение среза,
равное `-1`, то символы будут идти в обратном порядке.

```python
s = 'abcdefg'
print(s[::2])
print(s[::3])
```

Вывод:

```
aceg
adg
```

Например, можно перевернуть строку срезом `s[::-1]`

```python
s = 'abcdefg'
print(s[::-1])
```

Вывод:

```
gfedcba
```

## Методы

Метод — это функция, применяемая к объекту, в данном случае — к строке. Метод вызывается в
виде `Имя_объекта.Имя_метода(параметры)`. Например, `s.find("e")` — это применение к строке `s`  метода `find` с одним
параметром `"e"`.

### Методы find и rfind

Метод `find` находит в данной строке (к которой применяется метод) данную подстроку (которая передается в качестве
параметра). Функция возвращает индекс первого вхождения искомой подстроки. Если же подстрока не найдена, то метод
возвращает значение -1.

```python
s = 'Hello'
print(s.find('e'))
print(s.find('ll'))
print(s.find('L'))
```

Вывод:

```
1
2
-1
```

Аналогично, метод `rfind` возвращает индекс последнего вхождения данной строки («поиск справа»).

```python
s = 'Hello'
print(s.find('l'))
print(s.rfind('l'))
```

Вывод:

```
2
3
```

Если вызвать метод `find` с тремя параметрами `s.find(T, a, b)`, то поиск будет осуществляться в срезе `s[a:b]`. Если
указать только два параметра `s.find(T, a)`, то поиск будет осуществляться в срезе `s[a:]`, то есть начиная с символа с
индексом `a` и до конца строки. Метод `s.find(T, a, b)`  возращает индекс в строке `s`, а не индекс относительно среза.

```python
s = 'Hello world!'
s.find('l')
s.find('l', 5, 100)
```

Вывод:

```
2
9
```

### Метод replace

Метод `replace` заменяет все вхождения одной строки на другую. Формат: `s.replace(old, new)` — заменить в строке `s`
все вхождения подстроки `old` на подстроку `new`. _(см. Пример 6)_

```python
print('Hello'.replace('l', 'L'))
```

Вывод:

```
HeLLo
```

Если методу `replace` задать еще один параметр: `s.replace(old, new, count)`, то заменены будут не все вхождения, а
только не больше, чем первые `count` из них.

только не больше, чем первые `count` из них.

```python
print('Abrakadabra'.replace('a', 'A'))
print('Abrakadabra'.replace('a', 'A', 2))
```

Вывод:

```
AbrAkAdAbrA
AbrAkAdabra
```

### Метод count

Подсчитывает количество вхождений одной строки в другую строку. Простейшая форма вызова `s.count(T)`  возвращает число
вхождений строки `T` внутри строки `s`. При этом подсчитываются только непересекающиеся вхождения.

```python
print('Abracadabra'.count('a'))
print(('a' * 10).count('aa'))
```

Вывод:

```
4
5
```

### Метод strip

Метод `strip()` возвращает копию строки, удаляя как начальные, так и конечные символы (в зависимости от переданного строкового аргумента). Метод удаляет символы как слева, так и справа в зависимости от аргумента (строка, определяющая набор символов, которые необходимо удалить). 
По умолчанию удаляет пробельные символы:
```python
s = ' xoxo love xoxo '  
print(s.strip())
print(s.strip(' xoe'))
``` 

Вывод:

```
xoxo love xoxo
lov
```


> ### Примечание:
>
> Следующие методы во время своей работы производят/потребляют иной тип данных – _списки_. Подробней о них будет расскзано позднее.

### Метод split

Разбивает строку на части, используя разделитель, и возвращает эти части списком. Направление разбиения: слева направо.
Простейшая форма вызова `s.split()` возвращает список строк разделённых по всем пробелам:

```python
s = 'Hello  world!'
print(s.split())
print('Abra   ca da   bra'.split())
```

Вывод:

```
['Hello', 'world!']
['Abra', 'ca', 'da', 'bra']
```

```python
'1,2,3'.split(',')  
```

Вывод:

```
['1', '2', '3']
```

### Метод join

Метод `join` в Python отвечает за объединение списка строк с помощью определенного разделителя. Часто это используется при
конвертации списка в строку. Например, так можно конвертировать список букв алфавита в разделенную запятыми строку для
сохранения.

> **Примечание:**
> 
> Пустая строка `''` часто используется, чтобы получать строку, без дополнительных символов.   

```python
ls = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
s = ''.join(ls)
print(s)  
```

Вывод:

```
abcdefg
```

```python
ls = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
s = ' '.join(ls)
print(s)  
```

Вывод:

```
a b c d e f g
```

Метод принимает итерируемый объект в качестве аргумента, а поскольку список отвечает этим условиям, то его вполне можно
использовать. Также список должен состоять из строк. Если попробовать использовать функцию для списка с другим
содержимым, то результатом будет ошибка:

```python
ls = [1, 'a', 'b', 'c', 'd', 'e', 'f', 'g']
s = ''.join(ls)
```

Вывод:

```
TypeError: sequence item 0: expected str instance, int found.
```

